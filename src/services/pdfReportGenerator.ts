/**
 * PDF Report Generator Service
 * Generates forensic reports with watermark and optional password protection
 */

export interface ReportData {
  title: string
  content: string
  documentInfo?: {
    fileName: string
    hash: string
    timestamp: number
    jurisdiction?: string
  }
  sealInfo?: {
    sealedBy: string
    location?: string
    timestamp: number
  }
}

export interface PDFOptions {
  password?: string
  includeWatermark: boolean
  watermarkOpacity?: number
}

/**
 * Generate a text-based forensic report with watermark indicator
 * Note: True PDF generation with watermark requires a library like jsPDF or pdfmake
 * This provides a template that can be converted to PDF
 */
export async function generateForensicReport(
  reportData: ReportData,
  options: PDFOptions = { includeWatermark: true }
): Promise<string> {
  const timestamp = new Date().toISOString()
  const watermarkNote = options.includeWatermark 
    ? '\n[WATERMARKED - See /assets/watermark.png for visual watermark]\n' 
    : ''
  const passwordNote = options.password 
    ? '\n[PASSWORD PROTECTED - Password required to view full content]\n' 
    : ''

  const report = `
═══════════════════════════════════════════════════════════════════
                    VERUM OMNIS FORENSIC REPORT
                        Legal Evidence Analysis
═══════════════════════════════════════════════════════════════════
${watermarkNote}${passwordNote}
Report Title: ${reportData.title}
Generated: ${timestamp}
Report ID: ${generateReportId()}

───────────────────────────────────────────────────────────────────
DOCUMENT INFORMATION
───────────────────────────────────────────────────────────────────
${reportData.documentInfo ? `
File Name: ${reportData.documentInfo.fileName}
Document Hash (SHA-256): ${reportData.documentInfo.hash}
Sealed Date: ${new Date(reportData.documentInfo.timestamp).toLocaleString()}
${reportData.documentInfo.jurisdiction ? `Jurisdiction: ${reportData.documentInfo.jurisdiction}` : ''}
` : 'No document information available'}

───────────────────────────────────────────────────────────────────
SEAL INFORMATION
───────────────────────────────────────────────────────────────────
${reportData.sealInfo ? `
Sealed By: ${reportData.sealInfo.sealedBy}
Seal Date: ${new Date(reportData.sealInfo.timestamp).toLocaleString()}
${reportData.sealInfo.location ? `Location: ${reportData.sealInfo.location}` : ''}
` : 'No seal information available'}

───────────────────────────────────────────────────────────────────
FORENSIC ANALYSIS
───────────────────────────────────────────────────────────────────

${reportData.content}

───────────────────────────────────────────────────────────────────
REPORT CERTIFICATION
───────────────────────────────────────────────────────────────────

This report was generated by Verum Omnis AI Forensics System.
All findings are based on automated forensic analysis and should be
reviewed by qualified legal professionals.

Report Hash: ${await generateReportHash(reportData)}
Certified: ${timestamp}

═══════════════════════════════════════════════════════════════════
                    END OF FORENSIC REPORT
═══════════════════════════════════════════════════════════════════
`

  // If password protected, obfuscate sensitive content
  if (options.password) {
    return obfuscateReport(report, options.password)
  }

  return report
}

/**
 * Generate unique report ID
 */
function generateReportId(): string {
  const timestamp = Date.now().toString(36)
  const random = Math.random().toString(36).substring(2, 9)
  return `VOR-${timestamp}-${random}`.toUpperCase()
}

/**
 * Generate hash of report content
 */
async function generateReportHash(reportData: ReportData): Promise<string> {
  const content = JSON.stringify(reportData)
  const encoder = new TextEncoder()
  const data = encoder.encode(content)
  const hashBuffer = await crypto.subtle.digest('SHA-256', data)
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16)
}

/**
 * Obfuscate report content with password requirement notice
 * In a real implementation, this would encrypt the content
 */
function obfuscateReport(report: string, password: string): string {
  const lines = report.split('\n')
  const obfuscatedLines = lines.map((line, index) => {
    // Keep headers and structural elements
    if (line.includes('═══') || line.includes('───') || 
        line.includes('VERUM OMNIS') || line.includes('PASSWORD PROTECTED') ||
        line.includes('WATERMARKED') || index < 10 || index > lines.length - 10) {
      return line
    }
    // Obfuscate content lines
    if (line.trim().length > 0) {
      return line.replace(/[A-Za-z0-9]/g, '█')
    }
    return line
  })

  const passwordHint = `

╔═══════════════════════════════════════════════════════════════════╗
║                     PASSWORD REQUIRED                              ║
║                                                                     ║
║  This report is password protected. To view the full content,     ║
║  please export this document as PDF and enter the password.        ║
║                                                                     ║
║  Password hash (first 8 chars): ${hashPassword(password).substring(0, 8)}...                    ║
╚═══════════════════════════════════════════════════════════════════╝

`

  return passwordHint + obfuscatedLines.join('\n')
}

/**
 * Simple password hash for verification
 */
function hashPassword(password: string): string {
  let hash = 0
  for (let i = 0; i < password.length; i++) {
    const char = password.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash
  }
  return Math.abs(hash).toString(16).padStart(16, '0')
}

/**
 * Export report with watermark metadata
 */
export async function exportReportWithWatermark(
  reportData: ReportData,
  options: PDFOptions = { includeWatermark: true }
): Promise<Blob> {
  const reportContent = await generateForensicReport(reportData, options)
  
  // Create blob with report content
  const blob = new Blob([reportContent], { type: 'text/plain' })
  
  return blob
}

/**
 * Get watermark image data URL
 */
export function getWatermarkUrl(): string {
  return '/assets/watermark.png'
}

/**
 * Check if password is valid for a password-protected report
 */
export function validateReportPassword(report: string, password: string): boolean {
  const hashMatch = report.match(/Password hash \(first 8 chars\): ([a-f0-9]{8})/)
  if (!hashMatch) return false
  
  const reportHash = hashMatch[1]
  const inputHash = hashPassword(password).substring(0, 8)
  
  return reportHash === inputHash
}
